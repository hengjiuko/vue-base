1. Vue 实例

1.1 创建一个Vue实例

一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。

1.2 数据与方法

数据的响应式渲染

当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。(注意的是只有当实例被创建时 data 中存在的属性才是响应式的。) 
使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。

实例属性与方法

除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。


2. 模版语法

2.1 指令

指令 (Directives) 是带有 v- 前缀的特殊特性。 
如：缩写 v-bind缩写 : , v-on缩写 @

3. 计算属性和侦听器

3.1 计算属性
   关键词：computed

3.2 侦听器
     watch和vm.$watch API

3.3 Class 与 Style 绑定
   用 v-bind
4.1 绑定 HTML Class

(1)对象语法

传给 v-bind:class 一个对象，以动态地切换 class demo , v-bind:class 指令也可以与普通的 class 属性共存 
(2)用在组件上

当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。

4.2 绑定内联样式

对象语法

v-bind:style 的对象语法十分直观――看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名demo。，直接绑定到一个样式对象通常更好，这会让模板更清晰demo,同样的，对象语法常常结合返回对象的计算属性使用。

数组语法

v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上 demo

自动添加前缀

当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。


5. 条件渲染

5.1 v-if

在<template> 元素上使用 v-if 条件渲染分组

v-if 指令必须添加到一个元素上,如果想切换元素,可以把一个 <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 <template> 元素。demo

v-else

使用 v-else 指令来表示 v-if 的“else 块”demo 
v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。

v-else-if

v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用demo 
类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。

用 key 管理可复用的元素

Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换demo,代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<input>不会被替换掉――仅仅是替换了它的 placeholder。 
这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可demo,注意，<label> 元素仍然会被高效地复用，因为它们没有添加 key 属性。

5.2 v-show

另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样demo, 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。注意，v-show 不支持 <template> 元素，也不支持 v-else。

5.3 v-if vs v-show

v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做――直到条件第一次变为真时，才会开始渲染条件块。 
相比之下，v-show 就简单得多――不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

5.4 v-if 与 v-for 一起使用

当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。

6. 列表渲染

6.1 用 v-for 把一个数组对应为一组元素

我们用 v-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名demo 。在 v-for 块中，我们拥有对父作用域属性的完全访问权限。v-for 还支持一个可选的第二个参数为当前项的索引demo。你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法demo。

6.2 一个对象的 v-for

你也可以用 v-for 通过一个对象的属性来迭代。你也可以提供第二个的参数为键名。第三个参数为索引。 注意，在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。

6.3 key

当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 
6.4 显示过滤/排序结果

有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中)。

6.5一段取值范围的 v-for

v-for 也可以取整数。在这种情况下，它将重复多次模板demo。

6.6v-for on a <template>

类似于 v-if，你也可以利用带有 v-for 的 <template> 渲染多个元素demo。

6.7 v-for with v-if

当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用demo。而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <template>)上demo。

6.8一个组件的 v-for

在自定义组件里，你可以像任何普通元素一样用 v-for 。然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 props。demo

7. 事件处理

7.1 监听事件

可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。demo

7.2 事件处理方法

然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。demo

7.3 内联处理器中的方法

除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法demo 
有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法demo

7.4 按键修饰符

在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符demo,记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名,如.enter demo。 
全部的按键别名：.enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 
可以通过全局 config.keyCodes 对象自定义按键修饰符别名demo。

自动匹配按键修饰符

你也可直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符

<input @keyup.page-down="onPageDown">
7.5 系统修饰键

可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 
.ctrl .alt .shift .meta demo

鼠标按钮修饰符

7.6 为什么在 HTML 中监听事件?

可以注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处： 
扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 
因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 
当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。

8. 表单输入绑定

8.1 基础用法

用 v-model 指令在表单 <input> 及 <textarea> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 v-model 本质上是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 

8.2修饰符

.lazy 添加 lazy 修饰符，是v-model转变为使用 change 事件进行同步demo实时更新 
.number 自动将用户的输入值转为数值类型demo 
.trim 自动过滤用户输入的首尾空白字符demo

8.3 在组件上使用 v-model


9. 组件基础
   用component创建组件